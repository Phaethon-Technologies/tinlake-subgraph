type Pool @entity {
  id: ID!
  loans: [Loan!]! # TODO: maybe transform into a reverse lookup? https://thegraph.com/docs/define-a-subgraph#writing-mappings
  totalDebt: BigInt!
  totalBorrowsCount: Int!
  totalBorrowsAggregatedAmount: BigInt!
  totalRepaysCount: Int!
  totalRepaysAggregatedAmount: BigInt!
  weightedInterestRate: BigInt!
  seniorDebt: BigInt!
  seniorInterestRate: BigInt!
  minJuniorRatio: BigInt!
  maxJuniorRatio: BigInt!
  currentJuniorRatio: BigInt!
  maxReserve: BigInt!
  seniorTokenPrice: BigInt! # assessor
  juniorTokenPrice: BigInt! # assessor
  juniorYield14Days: BigInt
  seniorYield14Days: BigInt
  juniorYield30Days: BigInt
  seniorYield30Days: BigInt
  reserve: BigInt!
  assetValue: BigInt!
  shortName: String!
  version: BigInt!
  addresses: PoolAddresses!
}

type PoolAddresses @entity {
  id: ID!
  coordinator: ID!
  assessor: ID!
  shelf: ID!
  pile: ID!
  feed: ID!
  reserve: ID!
  seniorToken: ID!
  juniorToken: ID!
  seniorTranche: ID!
  juniorTranche: ID!
}

type PoolRegistry @entity {
  id: ID! # address
  pools: [Pool!]!
}

type DailyPoolData @entity {
  id: ID! # poolId+day
  day: Day!
  pool: Pool!
  reserve: BigInt! # reserve.sol totalBalance()
  totalDebt: BigInt! # outstanding Volume (but also is already in the pool)
  assetValue: BigInt! # navfeed.sol currentNav()
  seniorDebt: BigInt!
  seniorTokenPrice: BigInt! # assessor
  juniorTokenPrice: BigInt! # assessor
  currentJuniorRatio: BigInt!
}

type Loan @entity {
  id: ID!
  pool: Pool!
  index: Int!
  nftId: String
  nftRegistry: Bytes!
  owner: Bytes!
  opened: Int!
  closed: Int
  debt: BigInt!
  interestRatePerSecond: BigInt
  ceiling: BigInt
  threshold: BigInt
  borrowsCount: Int!
  borrowsAggregatedAmount: BigInt!
  repaysCount: Int!
  repaysAggregatedAmount: BigInt!
}

type Proxy @entity {
  id: ID!
  owner: Bytes!
}

type Account @entity {
  id: ID! # account address
  dailyTokenBalances: [DailyInvestorTokenBalance!] @derivedFrom (field: "account")
  currentActiveInvestmentAmount: BigInt!
}

type ERC20Transfer @entity {
  id: ID!
  transaction: String! # txhash
  token: Token!
  from: String!
  to: String!
  amount: BigInt!
  pool: Pool!
}

# used in reward calc
type Token @entity {
  id: ID! # token address
  symbol: String
  owners: [Account!]!
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

# excludes system addresses
type TokenBalance @entity {
  id: ID! # account address + token address
  owner: Account!
  balance: BigInt!
  value: BigInt!
  token: Token!
  # payoutCurrencyAmount, # how much dai you get back - redemption
  # remainingRedeemToken); # how much drop the tranche has that it is trying to redeem to you
  # todo: on disburse event, reset pending
  pendingSupplyCurrency: BigInt! # dai not converted into drop/tin yet (remainingSupplyCurrency)
  supplyAmount: BigInt! # converted, but not disbursed yet (payoutTokenAmount)
  
}

type Day @entity {
  id: ID!
  reserve: BigInt! # sum for all pools active on this day
  totalDebt: BigInt! # sum for all pools active on this day
  assetValue: BigInt! # sum for all pools active on this day
  seniorDebt: BigInt! # sum for all pools active on this day
  dailyPoolData: [DailyPoolData!] @derivedFrom(field: "day")
}

type DailyInvestorTokenBalance @entity {
  id: ID! # investorAddress + poolId + day
  account: Account!
  day: Day!
  pool: Pool!
  seniorTokenAmount: BigInt!
  seniorTokenValue: BigInt!
  seniorSupplyAmount: BigInt!
  seniorPendingSupplyCurrency: BigInt!
  juniorTokenAmount: BigInt!
  juniorTokenValue: BigInt!
  juniorSupplyAmount: BigInt!
  juniorPendingSupplyCurrency: BigInt!
}

type PoolInvestor @entity {
  id: ID! # poolId
  accounts: [String!]! # account addresses in pool
}

type GlobalAccountId @entity {
  id: ID! # systemwide '1'
  accounts: [String!]! # account addresses in system
}

# system wide by day
type RewardDayTotal @entity {
  id: ID! # date
  todayValue: BigInt!
  toDateAggregateValue: BigInt!
  rewardRate: BigDecimal!
  todayReward: BigDecimal!
  toDateRewardAggregateValue: BigDecimal!
}

# on claim changed event from contract
# create new reward claim for the eth address
type RewardBalance @entity {
  id: ID! # account address
  claims: [RewardClaim!]!
  eligible: Boolean! # rewards become eligible after investment length is greater than 60 consecutive days
  claimableRewards: BigDecimal! 
  previousRewards: BigDecimal! # rewards on previously linked address
  totalRewards: BigDecimal! # sum of the above 2
  nonZeroBalanceSince: BigInt! # system wide, has to have a non zero balance for at least the past 60 consecutive days
}

# this is a historical value and will not be responsible
# for keeping track of claims made on cent chain
# rewards earned from token investment
type RewardByToken @entity {
  id: ID! # investorAddress + token address
  token: String!
  account: String!
  rewards: BigDecimal!
}

# initial cent address is zero address
type RewardClaim @entity {
  id: ID! #eth address + cent address
  ethAddress: String!
  centAddress: String!
  rewardsAccumulated: BigDecimal!
}
