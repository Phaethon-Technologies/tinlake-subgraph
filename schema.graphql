type Pool @entity {
  id: ID!
  loans: [Loan!]! # TODO: maybe transform into a reverse lookup? https://thegraph.com/docs/define-a-subgraph#writing-mappings
  totalDebt: BigInt!
  totalBorrowsCount: Int!
  totalBorrowsAggregatedAmount: BigInt!
  totalRepaysCount: Int!
  totalRepaysAggregatedAmount: BigInt!
  weightedInterestRate: BigInt!
  seniorDebt: BigInt!
  seniorInterestRate: BigInt!
  minJuniorRatio: BigInt!
  maxJuniorRatio: BigInt!
  currentJuniorRatio: BigInt!
  reserve: BigInt!
  netAssetValue: BigInt!
  maxReserve: BigInt!
  shortName: String!
  version: BigInt!
}

type Loan @entity {
  id: ID!
  pool: Pool!
  index: Int!
  nftId: String
  nftRegistry: Bytes!
  owner: Bytes!
  opened: Int!
  closed: Int
  debt: BigInt!
  interestRatePerSecond: BigInt
  ceiling: BigInt
  threshold: BigInt
  borrowsCount: Int!
  borrowsAggregatedAmount: BigInt!
  repaysCount: Int!
  repaysAggregatedAmount: BigInt!
}

type Proxy @entity {
  id: ID!
  owner: Bytes!
}

type Account @entity {
  id: ID! # address
  tokenBalances: [TokenBalance!] @derivedFrom (field: "owner")
  currentActiveInvestmentAmount: BigInt # not based on token balance
}

type ERC20Transfer @entity {
  id: ID!
  transaction: String # txhash
  token: Token!
  from: String
  to: String
  amount: BigInt
  pool: Pool!
}

type Token @entity {
  id: ID! # token address
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "token")
}

type TokenBalance @entity {
  id: ID! # account address + token address 
  owner: Account!
  balance: BigInt!
  value: BigInt!
  token: Token!
}